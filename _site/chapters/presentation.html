<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>References</title>
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
  <link rel="stylesheet" href="/probLang/assets/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  <!-- <link rel="stylesheet" href="/probLang/assets/css/editor.css"> -->
  <!-- <link rel="stylesheet" href="/probLang/assets/css/webppl-viz.css"> -->
  <link rel="stylesheet" href="http://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-editor-1.0.1.css">
  <link rel="stylesheet" href="http://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-viz-0.7.6.css">
  <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
  <link rel="canonical" href="http://localhost:4000/probLang/chapters/presentation.html">
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script>
  <script src="/probLang/assets/js/parse-bibtex.js"></script>
  <script src="/probLang/assets/js/main.js"></script>
  <!-- <script src="/probLang/assets/js/webppl-editor.js"></script> -->
  <!-- <script src="/probLang/assets/js/webppl-viz.js"></script>   -->
  <!-- <script src="/probLang/assets/js/webppl.min.js" defer async></script> -->
  <script src="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-editor-1.0.9.js"></script>
  <script src="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-viz-0.7.11.js"></script>
  <script src="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-v0.9.7.js" defer async></script>
</head>


  <body>

    <header class="site-header">
  <a class="site-title" href="/probLang/">Probabilistic languge understanding</a>
</header>


    <div class="page-content-wrapper">
      <div class="page-content">
        <h1 class="chapter-title">References</h1>

<h3 id="references">References</h3>

<p>Introduction</p>

<h4 id="section-1-semantic-theory">Section 1: Semantic Theory</h4>
<p>Talk about semantic theory.</p>

<h4 id="section-2-simple-model">Section 2: Simple Model</h4>

<p>Let us first consider a simplified model where there are no lifted threshold variables.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Possible utterances
var utterances = ['null','he', 'she', 'that boy', 'that girl', 'the tall boy',
                 'the short boy', 'the tall girl', 'the short girl']

var utterancePrior = function(){
  var ps = [4,3,3,2,2,1,1,1,1]
  var n = 1
  return categorical(map(function(x){x+n}, ps), utterances)
}

var state0 = [
  {
    gender: "male",
    height: "tall",
  },
  {
    gender: "male",
    height: "short",
  },
  {
    gender: "female",
    height: "tall",
  },
  {
    gender: "female",
    height: "short",
  },
]

// Add an access value to each entity in the above state.
var statePrior = function() {
  return map(function(x){
    var access = uniformDraw([1,2,3])
    return {
      gender: x.gender,
      height: x.height,
      access: access,
    }
  }, state0)
}

// Extract a referent from a state.
var refPrior = function(state) {
  var n = 0
  var ps = map(function(x){return x["access"] + n}, state)
  var ref = categorical(ps, state)
  return ref
}
</code></pre></div></div>

<h4 id="section-3">Section 3</h4>
<p>Now recall the very first model we’ve seen in this class from Frank and Goodman, 2014.
We have a fully enumerated state and a non-probabilistic interpretation function.
How does their exact model perform on this data?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///fold:
// Possible utterances
var utterances = ['null','he', 'she', 'that boy', 'that girl', 'the tall boy',
                 'the short boy', 'the tall girl', 'the short girl']

var utterancePrior = function(){
  var ps = [4,3,3,2,2,1,1,1,1]
  var n = 1
  return categorical(map(function(x){x+n}, ps), utterances)
}

var state0 = [
  {
    gender: "male",
    height: "tall",
  },
  {
    gender: "male",
    height: "short",
  },
  {
    gender: "female",
    height: "tall",
  },
  {
    gender: "female",
    height: "short",
  },
]

// Add an access value to each entity in the above state.
var statePrior = function() {
  return map(function(x){
    var access = uniformDraw([1,2,3])
    return {
      gender: x.gender,
      height: x.height,
      access: access,
    }
  }, state0)
}

// Extract a referent from a state.
var refPrior = function(state) {
  var n = 0
  var ps = map(function(x){return x["access"] + n}, state)
  var ref = categorical(ps, state)
  return ref
}
///

// Literal meaning function.
var literalMeanings = function(utterance, referent){
  return (utterance == 'he' || utterance == 'that boy') ?
    referent.gender == 'male' :
  (utterance == 'she' || utterance == 'that girl') ?
    referent.gender == 'female' :
  utterance == 'the tall boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'short') :
  utterance == 'the tall girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'short') :
  true
}

// L0
// p(ref=ent | utterance=utt, state) = [utt](ent) * p(ref=ent)
var literalListener = function(utterance,state){
  return Infer({model: function(){
    var ref = refPrior(state)
    condition(literalMeanings(utterance,ref))
    return ref
  }})
}

// optimality
var alpha = 1

// S1
// p(utterance=utt | ref=ent, state; l0) 
//     = p(ref=ent | utterance=utt, state; l0) * p(utterance=utt)
var speaker = function(state, referent){
  Infer({model: function(){
    var utterance = utterancePrior()
    factor(alpha * literalListener(utterance,state).score(referent))
    return utterance
  }})
}

// L1
// p(ref=ent | utterance=utt, state; s1)
//     = p(utterance=utt | ref=ent, state; s1) * p(ref=ent)
var pragmaticListener = function(utterance,state){
  Infer({model: function(){
    var referent = refPrior(state);
    observe(speaker(state,referent), utterance)
    return referent
  }})
}

var state = statePrior()

print("State")
var printer = map(function(ent) {
  print(ent)
}, state)

print("\n")
print("S1")
var printer = map(function(ref) {
    print("referring to")
    print(ref)
    viz.table(speaker(state, ref))
}, state)

print("\n")
print("L1")
var printer = map(function(utt) {
  print("when hearing '" + utt + "'")
  viz.table(pragmaticListener(utt, state))
}, utterances)
</code></pre></div></div>

<h4 id="section-4">Section 4</h4>

<p>What happens if we add an S2?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///fold:
// Possible utterances
var utterances = ['null','he', 'she', 'that boy', 'that girl', 'the tall boy',
                 'the short boy', 'the tall girl', 'the short girl']

var utterancePrior = function(){
  var ps = [4,3,3,2,2,1,1,1,1]
  var n = 1
  return categorical(map(function(x){x+n}, ps), utterances)
}

var state0 = [
  {
    gender: "male",
    height: "tall",
  },
  {
    gender: "male",
    height: "short",
  },
  {
    gender: "female",
    height: "tall",
  },
  {
    gender: "female",
    height: "short",
  },
]

// Add an access value to each entity in the above state.
var statePrior = function() {
  return map(function(x){
    var access = uniformDraw([1,2,3])
    return {
      gender: x.gender,
      height: x.height,
      access: access,
    }
  }, state0)
}

// Extract a referent from a state.
var refPrior = function(state) {
  var n = 0
  var ps = map(function(x){return x["access"] + n}, state)
  var ref = categorical(ps, state)
  return ref
}

// Literal meaning function.
var literalMeanings = function(utterance, referent){
  return (utterance == 'he' || utterance == 'that boy') ?
    referent.gender == 'male' :
  (utterance == 'she' || utterance == 'that girl') ?
    referent.gender == 'female' :
  utterance == 'the tall boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'short') :
  utterance == 'the tall girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'short') :
  true
}

// L0
// p(ref=ent | utterance=utt, state) = [utt](ent) * p(ref=ent)
var literalListener = function(utterance,state){
  return Infer({model: function(){
    var ref = refPrior(state)
    condition(literalMeanings(utterance,ref))
    return ref
  }})
}

// optimality
var alpha = 1

// S1
// p(utterance=utt | ref=ent, state; l0) 
//     = p(ref=ent | utterance=utt, state; l0) * p(utterance=utt)
var speaker = function(state, referent){
  Infer({model: function(){
    var utterance = utterancePrior()
    factor(alpha * literalListener(utterance,state).score(referent))
    return utterance
  }})
}

// L1
// p(ref=ent | utterance=utt, state; s1)
//     = p(utterance=utt | ref=ent, state; s1) * p(ref=ent)
var pragmaticListener = function(utterance,state){
  Infer({model: function(){
    var referent = refPrior(state);
    observe(speaker(state,referent), utterance)
    return referent
  }})
}

var state = statePrior()

///
// S2
// p(utterance=utt | ref=ent, state; l1)
//     = p(ref=ent | utterance=utt, state, l1) * p(utterance=utt)
var pragmaticSpeaker = function(state, referent) {
  Infer({model: function() {
    var utterance = utterancePrior()
    factor(alpha * pragmaticListener(utterance, state).score(referent))
    return utterance
  }})
}

print("\n")
print("S1")
var printer = map(function(ref) {
  print("referring to")
  print(ref)
  viz.table(speaker(state, ref))
}, state)

print("\n")
print("S2")
var printer = map(function(ref) {
  print("referring to")
  print(ref)
  viz.table(pragmaticSpeaker(state, ref))
}, state)
</code></pre></div></div>

<h4 id="section-5">Section 5</h4>

<p>Interestingly enough, the utterance predictions are almost exactly the same.</p>

<h4 id="section-6-threshold-model">Section 6: Threshold Model</h4>

<p>Since there is no improvement with an additional S2, we instead consider a reformulation 
of the model.</p>

<p>We introduce two accessibility thresholds. One each for the demonstrative and pronoun referring expressions.
Intuitively, we assume that either referring expression
is used if an entity’s latent access variable is greater than or equal to the 
corresponding threshold, with the pronoun RE taking precedence over the demonstrative.
If the entity’s access is lower than both thresholds, we default to the definite description.</p>

<p>This is indeed similar to the Tessler and Goodman model of generics in spirit.
A referring expression is “endorsed” if an entity’s access exceeds a threshold.
However, the main difference is that there are multiple thresholds which have an ordering according to preference. 
Rather than just endorsing a referring expression in isolation,
the speaker must pick the expression that has the highest preference as well as appropriate threshold according to the entity’s accessibility.</p>

<p>We introduce a softer meaning function in order to prevent all paths from having zero mass
during inference. This comes up, for example, in the following situation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var utterance = "he"
var state = [
  {
    gender: "female",
    height: "short",
    access : 1
  }
]
</code></pre></div></div>

<h4 id="section-7">Section 7:</h4>

<p>The solution is simple, albeit slightly hacky:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var softMeanings = function(utterance, referent, theta_dem, theta_pro){
  return utterance == "null" ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'he' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'she' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'that boy' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'that girl' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'the tall boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'short') :
  utterance == 'the tall girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'short') :
  false
};
</code></pre></div></div>

<h4 id="section-8">Section 8:</h4>

<p>We now present the threshold model in its entirety.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///fold:
// Utility Functions

var printList = function(xs) {map(function(x){
  print(x)
}, xs)}

var swapElems = function(i, j, xs) {
  var val = xs[i]
  xs.splice(i, 1, xs[j])
  xs.splice(j, 1, val)
  return xs
}

var randomInt = function(lower, upper) {
  var int = randomInteger(upper-lower+1)
  return int+lower
}

var knuthShuffle = function(xs) {
  var len = xs.length
  var rands = mapN(function(n){return [n, randomInteger(n+1)]}, len)
  var ok = reduce(function(x, acc){
    var i = x[0]
    var j = x[1]
    return swapElems(i, j, acc)
  }, xs, rands)
  return ok
}

// Possible properties.
var genders = ["male", "female"]
var heights = ["short", "tall"]
var accesses = [1,2,3]

// A scoring function for sorting.
var score = function(x) {
  var g = x.gender === "female" ? 100 : 200
  var h = x.height === "short" ? 10 : 20
  var a = x.access
  return g + h + a
}

// A fully enumerated state.
var fullState = [].concat.apply([], map(function(gender){
  [].concat.apply([], map(function(height){
    [].concat.apply([], map(function(access){
      return {
        gender: gender,
        height: height,
        access: access
      }
    }, accesses))
  }, heights))
}, genders))
// Sort using score function.
var fullState = sort(fullState, lt, score)

// A partial state.
var state = [
  {
    gender: "male",
    height: "short",
    access: 1
  },
  {
    gender: "male",
    height: "tall",
    access: 1
  },
  {
    gender: "female",
    height: "short",
    access: 1
  },

  {
    gender: "female",
    height: "tall",
    access: 3
  },
]

// Sample n random entities from the fully enumerated state
// without replacement
var statePrior = function(n, state) {
  var shuffled = knuthShuffle(state)
  return sort(shuffled.slice(0, n), lt, score)
}

// Shadow partial state with fullState.
var state = fullState

// Possible utterances
var utterances = ['null','he', 'she', 'that boy', 'that girl', 'the tall boy',
                 'the short boy', 'the tall girl', 'the short girl']

var utterancePrior = function(){
  var ps = [4,3,3,2,2,1,1,1,1]
  var n = 1
  return categorical(map(function(x){x+n}, ps), utterances)
};

var softMeanings = function(utterance, referent, theta_dem, theta_pro){
  return utterance == "null" ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'he' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'she' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'that boy' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'that girl' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'the tall boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'short') :
  utterance == 'the tall girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'short') :
  false
};

///

// Theta prior.
var thetaPrior = function(){
  return uniformDraw([1,2,3])
};

// L0
// p(ref=ent | utterance=utt, state) = [utt](ent) * p(ref=ent)
var literalListener = function(utterance,state, theta_dem, theta_pro){
  return Infer({model: function(){
    var ref = uniformDraw(state);
    condition(softMeanings(utterance,ref,theta_dem,theta_pro))

    return ref
  }})
};

// optimality
var alpha = 1

// S1
// p(utterance=utt | ref=ent, state; l0) 
//     = p(ref=ent | utterance=utt, state; l0) * p(utterance=utt)
var speaker = function(state, referent, theta_dem, theta_pro){
  Infer({model: function(){
    var utterance = utterancePrior()
    factor(alpha * literalListener(utterance,state,theta_dem,theta_pro).score(referent))
    return utterance
  }})
};

// L1
// p(ref=ent | utterance=utt, state; s1)
//     = p(utterance=utt | ref=ent, state; s1) * p(ref=ent)
var pragmaticListener = function(utterance,state){
  Infer({model: function(){
    var referent = uniformDraw(state);
    var theta_dem = thetaPrior()
    var theta_pro = thetaPrior()
    observe(speaker(state,referent,theta_dem,theta_pro), utterance)
    return referent
  }})
};

// S2
// p(utterance=utt | ref=ent, state; l1)
//     = p(ref=ent | utterance=utt, state, l1) * p(utterance=utt)
var pragmaticSpeaker = function(state, referent) {
  Infer({model: function() {
    var utterance = utterancePrior()
    factor(alpha * pragmaticListener(utterance, state).score(referent))
    return utterance
  }})
}

</code></pre></div></div>

<h4 id="section-9-fully-enumerated-state">Section 9: Fully enumerated state</h4>

<p>How does this model do?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///fold:
// Utility Functions

var printList = function(xs) {map(function(x){
  print(x)
}, xs)}

var swapElems = function(i, j, xs) {
  var val = xs[i]
  xs.splice(i, 1, xs[j])
  xs.splice(j, 1, val)
  return xs
}

var randomInt = function(lower, upper) {
  var int = randomInteger(upper-lower+1)
  return int+lower
}

var knuthShuffle = function(xs) {
  var len = xs.length
  var rands = mapN(function(n){return [n, randomInteger(n+1)]}, len)
  var ok = reduce(function(x, acc){
    var i = x[0]
    var j = x[1]
    return swapElems(i, j, acc)
  }, xs, rands)
  return ok
}

// Possible properties.
var genders = ["male", "female"]
var heights = ["short", "tall"]
var accesses = [1,2,3]

// A scoring function for sorting.
var score = function(x) {
  var g = x.gender === "female" ? 100 : 200
  var h = x.height === "short" ? 10 : 20
  var a = x.access
  return g + h + a
}

// A fully enumerated state.
var fullState = [].concat.apply([], map(function(gender){
  [].concat.apply([], map(function(height){
    [].concat.apply([], map(function(access){
      return {
        gender: gender,
        height: height,
        access: access
      }
    }, accesses))
  }, heights))
}, genders))
// Sort using score function.
var fullState = sort(fullState, lt, score)

// Sample n random entities from the fully enumerated state
// without replacement
var statePrior = function(n, state) {
  var shuffled = knuthShuffle(state)
  return sort(shuffled.slice(0, n), lt, score)
}

// Shadow partial state with fullState.
var state = fullState

// Possible utterances
var utterances = ['null','he', 'she', 'that boy', 'that girl', 'the tall boy',
                 'the short boy', 'the tall girl', 'the short girl']

var utterancePrior = function(){
  var ps = [4,3,3,2,2,1,1,1,1]
  var n = 1
  return categorical(map(function(x){x+n}, ps), utterances)
};

var softMeanings = function(utterance, referent, theta_dem, theta_pro){
  return utterance == "null" ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'he' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'she' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'that boy' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'that girl' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'the tall boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'short') :
  utterance == 'the tall girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'short') :
  false
};

// Theta prior.
var thetaPrior = function(){
  return uniformDraw([1,2,3])
};

// L0
// p(ref=ent | utterance=utt, state) = [utt](ent) * p(ref=ent)
var literalListener = function(utterance,state, theta_dem, theta_pro){
  return Infer({model: function(){
    var ref = uniformDraw(state);
    condition(softMeanings(utterance,ref,theta_dem,theta_pro))

    return ref
  }})
};

// optimality
var alpha = 1

// S1
// p(utterance=utt | ref=ent, state; l0) 
//     = p(ref=ent | utterance=utt, state; l0) * p(utterance=utt)
var speaker = function(state, referent, theta_dem, theta_pro){
  Infer({model: function(){
    var utterance = utterancePrior()
    factor(alpha * literalListener(utterance,state,theta_dem,theta_pro).score(referent))
    return utterance
  }})
};

// L1
// p(ref=ent | utterance=utt, state; s1)
//     = p(utterance=utt | ref=ent, state; s1) * p(ref=ent)
var pragmaticListener = function(utterance,state){
  Infer({model: function(){
    var referent = uniformDraw(state);
    var theta_dem = thetaPrior()
    var theta_pro = thetaPrior()
    observe(speaker(state,referent,theta_dem,theta_pro), utterance)
    return referent
  }})
};

// S2
// p(utterance=utt | ref=ent, state; l1)
//     = p(ref=ent | utterance=utt, state, l1) * p(utterance=utt)
var pragmaticSpeaker = function(state, referent) {
  Infer({model: function() {
    var utterance = utterancePrior()
    factor(alpha * pragmaticListener(utterance, state).score(referent))
    return utterance
  }})
}

///

print("\n")
print("L1")
var printer = map(function(utt) {
  print("when hearing '" + utt + "'")
  viz.table(pragmaticListener(utt, state))
}, utterances)

print("\n")
print("S2")
var printer = map(function(ref) {
    print("referring to")
    print(ref)
    viz.table(pragmaticSpeaker(state, ref))
}, state)
</code></pre></div></div>

<h4 id="section-10-examining-a-special-case">Section 10: Examining a special case</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///fold:
// Utility Functions

var printList = function(xs) {map(function(x){
  print(x)
}, xs)}

var swapElems = function(i, j, xs) {
  var val = xs[i]
  xs.splice(i, 1, xs[j])
  xs.splice(j, 1, val)
  return xs
}

var randomInt = function(lower, upper) {
  var int = randomInteger(upper-lower+1)
  return int+lower
}

var knuthShuffle = function(xs) {
  var len = xs.length
  var rands = mapN(function(n){return [n, randomInteger(n+1)]}, len)
  var ok = reduce(function(x, acc){
    var i = x[0]
    var j = x[1]
    return swapElems(i, j, acc)
  }, xs, rands)
  return ok
}

// Possible properties.
var genders = ["male", "female"]
var heights = ["short", "tall"]
var accesses = [1,2,3]

// A scoring function for sorting.
var score = function(x) {
  var g = x.gender === "female" ? 100 : 200
  var h = x.height === "short" ? 10 : 20
  var a = x.access
  return g + h + a
}

// A fully enumerated state.
var fullState = [].concat.apply([], map(function(gender){
  [].concat.apply([], map(function(height){
    [].concat.apply([], map(function(access){
      return {
        gender: gender,
        height: height,
        access: access
      }
    }, accesses))
  }, heights))
}, genders))
// Sort using score function.
var fullState = sort(fullState, lt, score)

// Sample n random entities from the fully enumerated state
// without replacement
var statePrior = function(n, state) {
  var shuffled = knuthShuffle(state)
  return sort(shuffled.slice(0, n), lt, score)
}

// Shadow partial state with fullState.
var state = fullState

// Possible utterances
var utterances = ['null','he', 'she', 'that boy', 'that girl', 'the tall boy',
                 'the short boy', 'the tall girl', 'the short girl']

var utterancePrior = function(){
  var ps = [4,3,3,2,2,1,1,1,1]
  var n = 1
  return categorical(map(function(x){x+n}, ps), utterances)
};

var softMeanings = function(utterance, referent, theta_dem, theta_pro){
  return utterance == "null" ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'he' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'she' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_pro ? 0.99 : 0.01) :
  utterance == 'that boy' &amp;&amp; referent.gender == 'male' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'that girl' &amp;&amp; referent.gender == 'female' ?
    flip(referent.access &gt;= theta_dem ? 0.99 : 0.01) :
  utterance == 'the tall boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short boy' ?
    (referent.gender == 'male' &amp;&amp; referent.height == 'short') :
  utterance == 'the tall girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'tall') :
  utterance == 'the short girl' ?
    (referent.gender == 'female' &amp;&amp; referent.height == 'short') :
  false
};

// Theta prior.
var thetaPrior = function(){
  return uniformDraw([1,2,3])
};

// L0
// p(ref=ent | utterance=utt, state) = [utt](ent) * p(ref=ent)
var literalListener = function(utterance,state, theta_dem, theta_pro){
  return Infer({model: function(){
    var ref = uniformDraw(state);
    condition(softMeanings(utterance,ref,theta_dem,theta_pro))

    return ref
  }})
};

// optimality
var alpha = 1

// S1
// p(utterance=utt | ref=ent, state; l0) 
//     = p(ref=ent | utterance=utt, state; l0) * p(utterance=utt)
var speaker = function(state, referent, theta_dem, theta_pro){
  Infer({model: function(){
    var utterance = utterancePrior()
    factor(alpha * literalListener(utterance,state,theta_dem,theta_pro).score(referent))
    return utterance
  }})
};

// L1
// p(ref=ent | utterance=utt, state; s1)
//     = p(utterance=utt | ref=ent, state; s1) * p(ref=ent)
var pragmaticListener = function(utterance,state){
  Infer({model: function(){
    var referent = uniformDraw(state);
    var theta_dem = thetaPrior()
    var theta_pro = thetaPrior()
    observe(speaker(state,referent,theta_dem,theta_pro), utterance)
    return referent
  }})
};

// S2
// p(utterance=utt | ref=ent, state; l1)
//     = p(ref=ent | utterance=utt, state, l1) * p(utterance=utt)
var pragmaticSpeaker = function(state, referent) {
  Infer({model: function() {
    var utterance = utterancePrior()
    factor(alpha * pragmaticListener(utterance, state).score(referent))
    return utterance
  }})
}

///

// A partial state.
var state = [
  {
    gender: "male",
    height: "short",
    access: 1
  },
  {
    gender: "male",
    height: "tall",
    access: 2
  },
  {
    gender: "female",
    height: "short",
    access: 2
  },

  {
    gender: "female",
    height: "tall",
    access: 3
  },
]

print("State")
printList(state)

print("\n")
print("L1")
var printer = map(function(utt) {
  print("when hearing '" + utt + "'")
  viz.table(pragmaticListener(utt, state))
}, utterances)

print("\n")
print("S2")
var printer = map(function(ref) {
    print("referring to")
    print(ref)
    viz.table(pragmaticSpeaker(state, ref))
}, state)
</code></pre></div></div>


<hr>

<a href="/probLang/">Table of Contents</a>

      </div>
    </div>

    <footer class="site-footer">
  <a href="github.com/probmods/ppaml2016" id="github-edit-link">Edit on Github</a>
</footer>

<script type="text/javascript">
  $("#github-edit-link").attr("href", github_page_url("/chapters/presentation.html"))
</script>


  </body>

</html>
